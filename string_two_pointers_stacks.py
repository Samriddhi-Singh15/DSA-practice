# -*- coding: utf-8 -*-
"""String/Two Pointers/Stacks

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Rn6JL3-XmDSl9Bg8nkzSVv1BcZ5z3eig
"""

#Longest substring without repeating character
def lengthOfLongestSubstring(self, s):
        left=right=max_len=0
        charSet=set()

        while right<len(s): #continuing to add character
            if s[right] not in charSet:
                charSet.add(s[right])
                max_len=max(max_len,right-left+1)
                right+=1
            else: #shifting left pointer
                charSet.remove(s[left])
                left+=1
        return max_len

#Longest Repeating Character Replacement
def characterReplacement(self, s, k):
        from collections import Counter
        count=Counter()
        left=maxFrequency=maxLen=0
        for right in range(len(s)):
            count[s[right]]+=1
            maxFrequency=max(maxFrequency,count[s[right]])

            if (right-left+1)-maxFrequency>k:
                count[s[left]]-=1
                left+=1
            maxLen=max(maxLen,right-left+1)
        return maxLen

#Minimum window substring
def minWindow(self, s, t):
    if not s or not t:
        return ""

    need = Counter(t)
    window = defaultdict(int)

    left = 0
    have = 0
    res_len = float("inf") #keeping it infinity
    need_size = len(need)
    res = [-1, -1]#nonsense value for now

    for right in range(len(s)):
        char = s[right]
        window[char] += 1

        if char in need and window[char] == need[char]: #window....=enough h??
            have += 1

        while have == need_size:

            if (right - left + 1) < res_len:#new window smaller than og one
                res = [left, right] #current best window
                res_len = right - left + 1 #how long the best id

            # Shrink the window
            window[s[left]] -= 1
            if s[left] in need and window[s[left]] < need[s[left]]:
                have -= 1
            left += 1

    l, r = res
    return s[l:r+1] if res_len != float('inf') else "" #[l,r+1] kuki python ek se pahle ruk jata h

#Valid Parenthesis
def isValid(self, s):
        stack=[]
        mapping={')':'(',']':'[','}':'{'}
        for i in s:
            if i in ["(","{","["]:
                stack.append(i)
            elif i in mapping:
                if not stack or stack[-1]!=mapping[i]:
                    return False
                stack.pop()
        if stack==[]:
            return True
        else:
            return False

#Permutation in string
def checkInclusion(self, s1, s2):
        from collections import Counter
        count_s1=Counter(s1)
        window_count={}
        left=0
        match_len=len(s1)

        for right in range(len(s2)):
            char=s2[right]
            if char not in count_s1:
                window_count.clear()
                left=right+1
                continue
            window_count[char]=window_count.get(char,0)+1

            if (right-left+1)>match_len:
               window_left=s2[left]
               window_count[window_left]-=1

               if window_count[window_left]==0:
                   del window_count[window_left]
               left+=1

            if window_count==count_s1:
                return True
        return False

#Max consecutive Ones
def findMaxConsecutiveOnes(self, nums):
        max_count=0
        count=0
        for i in nums:
            if i==1:
                count+=1
                max_count=max(max_count,count)
            if i==0:
                count=0
        return max_count

#Maximum average subarray

def findMaxAverage(self, nums, k):
        max_sum=sum(nums[:k])
        window_sum=max_sum

        for i in range(k,len(nums)):
            window_sum=window_sum-nums[i-k]+nums[i]

            max_sum=max(max_sum,window_sum)
        return max_sum*1.0/k

#maximum sum of distinct sub arrya

def maximumSubarraySum(self, nums, k):
        confirm_set=set()
        window_sum=max_sum=left=0
        for right in range(len(nums)):
            while nums[right] in confirm_set:
                confirm_set.remove(nums[left])
                window_sum-=nums[left]
                left+=1

            confirm_set.add(nums[right])
            window_sum+=nums[right]

            if right-left+1==k:
                max_sum=max(max_sum,window_sum)
                confirm_set.remove(nums[left])
                window_sum-=nums[left]
                left+=1

        return max_sum

#Fruits into Basket II
def numOfUnplacedFruits(self, fruits, baskets):
        used = [False] * len(baskets) #empty baskets
        unplaced = 0#how many we cant place

        for fruit in fruits:#going thru each fruit
            placed = False#track to know if currents fruits have been placed successfully
            for i in range(len(baskets)):#trying every basket
                if not used[i] and baskets[i] >= fruit:#not used and big enough
                    used[i] = True#marking as used
                    placed = True#fruit placed stop checking other basket
                    break
            if not placed:#if not placed
                unplaced += 1#no. it qas unplaced

        return unplaced

#Min stack
class MinStack(object):

    def __init__(self):
        self.Minstack=[]
        self.stack=[]

    def push(self, val):
        self.stack.append(val)
        if not self.Minstack or val<=self.Minstack[-1]:
            self.Minstack.append(val)

    def pop(self):
        val=self.stack.pop()
        if val==self.Minstack[-1]:
            self.Minstack.pop()


    def top(self):
        return self.stack[-1]

    def getMin(self):
        return self.Minstack[-1]

#Evaluate Reverse polish notation

def evalRPNI(tokens):
        stack=[]
        for i in tokens:
            if i.lstrip("-").isdigit():
                stack.append(i)
            elif i in ["+","-","*","/"]:
                stack2=int(stack.pop())
                stack1=int(stack.pop())
                if i=="+":
                    result=stack1+stack2
                elif i=="-":
                    result= stack1-stack2
                elif i=="*":
                    result=stack1 * stack2
                elif i=="/":
                    result=int(stack1/stack2)
                else:
                    print("invalid")
                stack.append(result)
        return result

def evalRPN(self,tokens):
        stack=[]
        ops={
          "+":operator.add,
          "-": operator.sub,
          "*":operator.mul,
          "/":lambda x,y:int(float(x)/y)
        }
        for token in tokens:
            if token in ops:
                b=stack.pop()
                a=stack.pop()
                stack.append(ops[token](a,b))
            else:
                stack.append(int(token))
        return stack[-1]

#Daily Temperature
def dailyTemperatures(self, temperatures):
        stack=[]
        result=[0] * len(temperatures)
        for i in range(len(temperatures)):
            while stack and temperatures[i]>temperatures[stack[-1]]:
                popped_out=stack.pop()
                result[popped_out]=i-popped_out
            stack.append(i)
        return result

#Next greater Element I
def nextGreaterElement(nums1, nums2):
  stack=[]
  my_dict={}
  for i in nums2:
    if not stack:
      stack.append(i)
    if stack[-1]<i:
      popped=stack.pop()
      my_dict[popped]=i
    if i==max(nums2) or i==nums2[-1]:
      my_dict[stack.pop()]=-1
  result=[my_dict[num] for num in nums1]
  return result



def nextGreaterElement(nums1, nums2):
  stack=[]
  my_dict={}
  for i in nums2:
    while stack and stack[-1]<i:
        popped=stack.pop()
        my_dict[popped]=i
    stack.append(i)
  while stack:
    my_dict[stack.pop()]=-1

  result=[my_dict[num] for num in nums1]
  return result

#Astroid collosion
def asteroidCollision(asteroids):
    stack = []
    for i in asteroids:
        while stack and i < 0 < stack[-1]:
            if stack[-1] < -i:
                stack.pop()
                continue
            elif stack[-1] == -i:
                stack.pop()
            break
        else:
            stack.append(i)
    return stack

asteroidCollision([10,2,-5])

#Reapeated Sum of 1 D array
def runningSum(self, nums):
        sum=0
        total=[]
        for i in nums:
            sum+=i
            total.append(sum)
        return total

#Largest Rectangle in Histogram
def largestRectangleArea(self, heights):
        stack=[]
        max_area=0
        n=len(heights)

        for i in range(n):
            while stack and heights[i]<heights[stack[-1]]:
                top=stack.pop()
                height=heights[top]

                width=i if not stack else i-stack[-1]-1

                area=height*width
                max_area=max(max_area,area)

            stack.append(i)


        while stack:
            top=stack.pop()
            height=heights[top]
            width=n if not stack else n-stack[-1]-1
            area=height*width
            max_area=max(max_area,area)
        return max_area

#car fleet
def carFleet(self, target, position, speed):
        if not position or not speed:
            return 0

        cars = list(zip(position, speed))
        cars.sort(key=lambda x: x[0], reverse=True)
        stack = []

        for pos, spd in cars:
            time = (target - pos) / float(spd)
            if not stack or time > stack[-1]:
                stack.append(time)

        return len(stack)

#palindrome
def isPalindrome(self, x):
        num=str(x)
        y=num[::-1]
        if num==y:
            result=True
        else:
           result=False
        return result