# -*- coding: utf-8 -*-
"""Arrays & Hashmaps

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MZ6n_Z16YxEmpj_M1QUEXH-ZTom9PPuy

Samriddhi Singh
DSA Practice-Array & Hashing
Basic level questions(20+)
Solved using Python
"""

#Two Sum
def twoSum(self, nums, target):
       prevMap={}

       for i , n in enumerate(nums):
           diff=target-n
           if diff in prevMap:
              return [prevMap[diff],i]
           else:
              prevMap[n]=i

#Best Time to Buy and Sell Stock
def maxProfit(self, prices):
    if not prices:
      return 0
    min_price=prices[0]
    max_price=0
    for price in prices[1:] :
        if price < min_price:
           min_price=price
        else:
           profit=price-min_price
           if profit > max_price:
                 max_price=profit
    return max_price

#Contains Duplicate
def containsDuplicate(self, nums):
       seen=set()
       for num in nums:
           if num in seen:
                return True
           else:
                seen.add(num)
       return False

#Valid Anagram
def isAnagram(self, s, t):
        from collections import Counter
        counter_s=Counter(s)
        counter_t=Counter(t)
        if counter_s==counter_t:
            return True
        return False

#Group anagram
def groupAnagrams(self, strs):
        groups={}
        for i in strs:
            sig=tuple(sorted(i))
            groups.setdefault(sig, []).append(i)
        return list(groups.values())

#Top K Frequent Elements
def topKFrequent(self, nums, k):
        from collections import Counter
        counter_ar=Counter(nums)
        top_k=counter_ar.most_common(k)
        return[item[0] for item in top_k]

#Product of Array Except Self
def productExceptSelf(nums):
        output=[1]*len(nums)
        left=1
        for i in range(len(nums)):
            output[i]=left
            left*=nums[i]

        right=1
        for i in reversed(range(len(nums))):
            output[i] *=right
            right *=nums[i]
        return output

#Maximum Subarray
def maxSubArray(nums):
        max_sum=curr_sum=nums[0]
        for i in nums[1:]:
             curr_sum=max(i,curr_sum+i)
             max_sum=max(max_sum,curr_sum)
        return max_sum

maxSubArray([-2,1])

#Merge Intervals
def merged(intervals):
  intervals.sort(key=lambda x:x[0])
  merge=[]
  for i in intervals:
    if not merge or  merge[-1][1]<i[0]:
      merge.append(i)
    else:
      merge[-1][1]=max(merge[-1][1],i[1])
  return merge

merged([[1,4],[2,6],[3,7],[9,15],[11,12],[16,18]])

#Insert Interval
def insert(self, intervals, newInterval):
        result=[]
        for i in intervals:
            if i[1]<newInterval[0]:
                result.append(i)
            elif i[0]>newInterval[1]:
                result.append(newInterval)
                newInterval=i
            else:
                newInterval[0]=min(newInterval[0],i[0])
                newInterval[1]=max(newInterval[1],i[1])
        result.append(newInterval)
        return result

#Longest Consecutive Sequence
def longestConsecutive( nums):
        nums_set=set(nums)
        longest_streak=0

        for num in nums_set:
            if num-1 not in nums_set:
                current_num=num
                current_streak=1
                while current_num+1 in nums_set:
                    current_num+=1
                    current_streak+=1

                longest_streak=max(longest_streak,current_streak)
        return longest_streak


longestConsecutive( [100,4,200,1,3,2])

#Majority Element
def majorityElement(nums):
        from collections import Counter
        count=Counter(nums)
        for key,value in count.items():
            if value>len(nums)//2:
                return key
        return nums[-1]


majorityElement([2,2,1,1,1,2,2])

#Missing Number
def missing(nums):
  nums_set=set(nums)
  max_num=max(nums)
  for i in range(0,max_num+1):
    if i not in nums_set:
      return i
  return max_num+1

#different solution
def missingNumber(nums):
  n=len(nums)
  expected_sum=n*(n+1)//2
  actual_sum=sum(nums)
  return expected_sum-actual_sum

#Intersection of Two Arrays
def intersection(nums1, nums2):
        nums1_set=set(nums1)
        nums2_set=set(nums2)
        result=nums1_set.intersection(nums2_set)
        return list(result)


intersection2([4,9,5],[9,4,9,8,4])

#Intersection of Two Arrays II
def intersection2(nums1, nums2):
    result1=[]
    collec=set()
    for i in nums1:
      collec.add(i)
    for i in nums2:
      if i in collec and i not in result1:
        result1.append(i)
    return result1

#Valid soduku
    def isValidSudoku(self, board):
        rows=[set() for i in range(9)]
        cols=[set() for i in range(9)]
        boxes=[set() for i in range(9)]

        for r in range(9):
            for c in range(9):
                val=board[r][c]
                if val==".":
                    continue
                box_index=(r//3)*3+(c//3)
                if val in rows[r] or val in cols[c] or val in boxes[box_index]:
                    return False

                rows[r].add(val)
                cols[c].add(val)
                boxes[box_index].add(val)
        return True

#Maximum Product Subarray

def maxProduct( nums):
        product=[]

        curr_product=max_product=nums[0]
        for i in nums[1:]:
            curr_product=max(i,i*curr_product)

            max_product=max(curr_product,max_product)
        return max_product

maxProduct([2,3,-2,4])

#Find Minimum in Rotated Sorted Array
def findMin(self, nums):
        left=0
        right=len(nums)-1
        while left<right:
            mid=(left+right)//2
            if nums[mid]>nums[right]:
                left=mid+1
            else:
                right=mid
        return nums[left]

#Search in Rotated Sorted Array
def search(self, nums, target):
        left=0
        right=len(nums)-1
        while left<=right:
            mid=(left+right)//2
            if nums[mid]==target:
                return mid
            if nums[left]<=nums[mid]:
                if nums[left] <= target < nums[mid]:
                    right=mid-1
                else:
                    left=mid+1
            else:
                if nums[mid] < target <=nums[right]:
                        left=mid+1
                else:
                        right=mid-1
        return -1

#Two Sum II
def twoSum(numbers, target):
        left=0
        right=len(numbers)-1
        while left < right:
            total=numbers[left]+numbers[right]
            if total==target:
                return left+1,right+1
            elif total>target:
                right=right-1
            else:
                left=left+1
        return left+1,right+1

twoSum([2,7,11,15],9)

#3Sum
def threeSum(self, nums):
        nums.sort()#helps with two pointer and skip duplicates
        result=[]
        for i in range(len(nums)):
            if i>0 and nums[i]==nums[i-1]:
                continue

            left=i+1
            right=len(nums)-1
            while left < right:
                total=nums[i]+nums[left]+nums[right]
                if total==0:
                    result.append([nums[i],nums[left],nums[right]])

                    while left<right and nums[left]==nums[left+1]:
                        left+=1
                    while left<right and nums[right]==nums[right-1]:
                        right-=1

                    left+=1
                    right-=1
                elif total<0:
                    left+=1
                else:
                    right-=1
        return result

#Container With Most Water
def maxArea(self, height):
        left=0
        right=len(height)-1
        max_area=0
        while left<right:
            height_container=min(height[left],height[right])
            width=right-left
            current_area=height_container*width
            max_area=max(max_area,current_area)
            if height[left]<height[right]:
                left+=1
            else:
                right-=1
        return max_area