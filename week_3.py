# -*- coding: utf-8 -*-
"""Week 3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OTVbU3QX9XkG4fOh7qtML4FGv9LSPjxo
"""

#car fleet
def carFleet(self, target, position, speed):
        if not position or not speed:
            return 0

        cars = list(zip(position, speed))
        cars.sort(key=lambda x: x[0], reverse=True)
        stack = []

        for pos, spd in cars:
            time = (target - pos) / float(spd)
            if not stack or time > stack[-1]:
                stack.append(time)

        return len(stack)

#palindrome
def isPalindrome(self, x):
        num=str(x)
        y=num[::-1]
        if num==y:
            result=True
        else:
           result=False
        return result

#Reapeated Sum of 1 D array
def runningSum(self, nums):
        sum=0
        total=[]
        for i in nums:
            sum+=i
            total.append(sum)
        return total

#simplify Path
def simplifyPath(path):
  stack=[]
  parts=path.split("/")
  for i in parts:
    if i==""  or i==".":
      continue
    elif i=="..":
      if stack:
        stack.pop()
      else:
        continue
    else:
      stack.append(i)
  result= "/"+"/". join(stack)
  return result

#Remove K digit
def removeKdigits(self, num, k):
        stack=[]

        for digit in num:
            while k>0 and stack and stack[-1]>digit:
                stack.pop()
                k-=1
            stack.append(digit)
        while k>0:
            stack.pop()
            k-=1
        result="".join(stack).lstrip('0')
        return result if result else '0'

removeKdigits("1432219",3)

#Longest Palindromic Substring
def longestPalindrome(s):
        if len(s)<=1:
            return s
        max_palin=''

        for centre in range(len(s)):


            l,r=centre,centre+1
            while l>=0 and r<len(s) and s[l]==s[r]:
                if r-l+1>len(max_palin):
                    max_palin=s[l:r+1]
                l-=1
                r+=1
            l,r=centre-1,centre+1
            while l>=0 and r<len(s) and s[l]==s[r]:
                if r-l+1>len(max_palin):
                    max_palin=s[l:r+1]
                l-=1
                r+=1

            if (max_palin)<1:
                max_palin=s[centre]
        return max_palin

#palindromic Substring
def countSubstringsI(s):#not for big cases
  final_list=list(s)


  for centre in range(len(s)):

            l,r=centre,centre+1
            while l>=0 and r<len(s) and s[l]==s[r]:
                dd=s[l:r+1]
                final_list.append(dd)
            l-=1
            r+=1

            l,r=centre-1,centre+1
            while l>=0 and r<len(s) and s[l]==s[r]:
                rd=s[l:r+1]
                final_list.append(rd)
            l-=1
            r+=1
  return len(final_list)



def countSubstrings(s):
  count=0
  for centre in range(len(s)):
    l=r=centre
    while l>=0 and r<len(s) and s[l]==s[r]:
      count+=1
      l-=1
      r+=1

    l,r=centre,centre+1
    while l>=0 and r<len(s) and s[l]==s[r]:
      count+=1
      l-=1
      r+=1
  return count

#valid Palindrome
def isPalindrome(s):
  clean="".join(c.lower() for c in s if c.isalnum())
  return clean==clean[::-1]

#Valid Word
def isValid(self, word):
        if len(word) < 3:
            return False

        vowels = "aeiouAEIOU"
        has_vowel = False
        has_consonant = False

        for char in word:
            if not char.isalnum():
                return False

            if char.isalpha():
                if char in vowels:
                    has_vowel = True
                else:
                    has_consonant = True

        return has_vowel and has_consonant

#Non-Overlapping
def eraseOverlapIntervals(intervals):
        if not intervals:
            return 0
        intervals.sort(key=lambda x:x[1])
        over_lapping=0
        prev_end=intervals[0][1]

        for i in range(1,len(intervals)):
            if intervals[i][0]<prev_end:
                over_lapping+=1
            else:
                prev_end=intervals[i][1]

        return over_lapping

#Single Number
def singleNumber(nums):
  from collections import Counter
  count_nums=Counter(nums)
  for key,value in count_nums.items():
    if value==1:
      result=key
  return result

#number of 1 bits
def hammingWeight(n):
  binary_search=bin(n)[2:]
  count=0
  for i in binary_search:
    if i=="1":
      count+=1
  return count

#counting Bits
def countBits(n):
  output=[]
  for i in range(n+1):
    binary_ch=bin(i)[2:]
    sum=0
    for j in binary_ch:
      if j=="1":
        sum+=1
    output.append(sum)
  return output

#Reverse B(it
def reverseBits(n):
        n=int(n)
        str_num=bin(n)[2:].zfill(32)
        rev=str_num[::-1]
        normal_num=int(rev,2)
        #print(normal_num)
        return normal_num

#Sum of two integer
def getSum(self, a, b):
    MASK =  0x0xFFFFFFFF #only last 32 bits
    MAX_INT = 0x7FFFFFFF  #biggest number in 32 bits
    while b != 0:  #carry left tak
        carry = a & b    #addition
        a = (a ^ b) & MASK   # ^addition without carry
        b = (carry << 1) & MASK  # carry one place to left


    return a if a <= MAX_INT else ~(a ^ MASK) #positive or negative

#Climbing Stairs
def climbStairs(n):
        if n==1:
            return 1
        if n==2:
            return 2

        first=1
        second=2
        for i in range(3,n+1):
            third=first+second
            first=second
            second=third
        return second

#house Robber---> not correct ans, will pass only test case
def rob(nums):
  indexed_nums=[(value,index) for index,value in enumerate(nums)]

  sorted_nums=sorted(indexed_nums,key=lambda x:x[0], reverse=True)

  curr_money=0
  stack=[]

  for value,index in sorted_nums:
    if all(abs(index-picked)>1 for picked in stack): #all->go thru the whole stack
      curr_money+=value
      stack.append(index)
  return curr_money


rob([1,2])

def plusOne(digits):

  digi_int=int("".join(map(str,digits)))
  digi_one=digi_int+1
  return [int(ch) for ch in str(digi_one)]